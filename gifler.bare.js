// Generated by CoffeeScript 1.10.0
var Animator, Api, GifReader, createBufferCanvas, decodeFrames, getCanvasElement, gifler, wrapXhrCallback,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

GifReader = require('omggif').GifReader;


/*---
head : 'gifler()'
text :
  - This is the main entrypoint to the library.
  - Prepares an XHR request to load the GIF file.
  - Returns an API instance for interacting with the library.
args : 
  url : 'URL to .gif file'
return : 'a gifler Api instance object'
 */

gifler = function(url) {
  var aync, xhr;
  xhr = new XMLHttpRequest();
  xhr.open('GET', url, aync = true);
  xhr.responseType = 'arraybuffer';
  return new Api(xhr);
};

Api = (function() {
  function Api(xhr1) {
    this.xhr = xhr1;
  }


  /*---
  head : 'api.animate()'
  text :
    - >
      Renders the loaded GIF into the canvas matching
      the timing and effects of using and img tag.
  args : 
    selector : 'A <canvas> element or query selector for a <canvas> element.'
   */

  Api.prototype.animate = function(selector) {
    var canvas;
    canvas = getCanvasElement(selector);
    this.xhr.onload = wrapXhrCallback(function(animator) {
      return animator.animateInCanvas(canvas);
    });
    this.xhr.send();
    return this;
  };


  /*---
  head : 'api.frames()'
  text :
    - >
      Runs the animation on the loaded GIF, but passes the
      canvas context and GIF frame to the <b>onDrawFrame</b>
      callback for rendering.
    - >
      This gives you complete control of how the frame is drawn
      into the canvas context.
  args : 
    selector           : 'A <canvas> element or query selector for a <canvas> element.'
    onDrawFrame        : 'A callback that will be invoked when each frame should be drawn into the canvas. see Animator.onDrawFrame.'
    setCanvasDimesions : 'OPTIONAL. If true, the canvas''s size will be set to the dimension of the loaded GIF. default: false.'
   */

  Api.prototype.frames = function(selector, onDrawFrame, setCanvasDimesions) {
    var canvas;
    if (setCanvasDimesions == null) {
      setCanvasDimesions = false;
    }
    canvas = getCanvasElement(selector);
    this.xhr.onload = wrapXhrCallback(function(animator) {
      animator.onDrawFrame = onDrawFrame;
      return animator.animateInCanvas(canvas, setCanvasDimesions);
    });
    this.xhr.send();
    return this;
  };


  /*---
  head : 'api.get()'
  text :
    - >
      To get even more control, and for your convenience,
      this method allows you to access gifler's Animator
      object. The animator will be in an unstarted state,
      but can be started with a call to <b>animator.animateInCanvas()</b>
  args : 
    callback : 'A function which takes as its argument a gifler Animator instance object'
   */

  Api.prototype.get = function(callback) {
    this.xhr.onload = wrapXhrCallback(callback);
    this.xhr.send();
    return this;
  };

  return Api;

})();

wrapXhrCallback = function(callback) {
  return function(e) {
    return callback(new Animator(new GifReader(new Uint8Array(this.response))));
  };
};

getCanvasElement = function(selector) {
  var element, ref;
  if (typeof selector === 'string' && ((ref = (element = document.querySelector(selector))) != null ? ref.tagName : void 0) === 'CANVAS') {
    return element;
  } else if ((selector != null ? selector.tagName : void 0) === 'CANVAS') {
    return selector;
  } else {
    throw new Error('Unexpected selector type. Valid types are query-selector-string/canvas-element');
  }
};


/*
Creates a buffer canvas element since it is much faster to putImage than
putImageData.

The omggif library decodes the pixels into the full gif dimensions. We only
need to store the frame dimensions, so we offset the putImageData call.
 */

createBufferCanvas = function(frame, width, height) {
  var bufferCanvas, bufferContext, imageData;
  bufferCanvas = document.createElement('canvas');
  bufferContext = bufferCanvas.getContext('2d');
  bufferCanvas.width = frame.width;
  bufferCanvas.height = frame.height;
  imageData = bufferContext.createImageData(width, height);
  imageData.data.set(frame.pixels);
  bufferContext.putImageData(imageData, -frame.x, -frame.y);
  return bufferCanvas;
};


/*
Decodes the pixels for each frame (decompressing and de-interlacing) into a
Uint8ClampedArray, which is suitable for canvas ImageData.
 */

decodeFrames = function(reader, frameIndex) {
  var j, ref, results;
  return (function() {
    results = [];
    for (var j = 0, ref = reader.numFrames(); 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
    return results;
  }).apply(this).map((function(_this) {
    return function(frameIndex) {
      var frameInfo;
      frameInfo = reader.frameInfo(frameIndex);
      frameInfo.pixels = new Uint8ClampedArray(reader.width * reader.height * 4);
      reader.decodeAndBlitFrameRGBA(frameIndex, frameInfo.pixels);
      return frameInfo;
    };
  })(this));
};

Animator = (function() {
  function Animator(_reader) {
    var ref;
    this._reader = _reader;
    this._advanceFrame = bind(this._advanceFrame, this);
    this._nextFrameRender = bind(this._nextFrameRender, this);
    this._nextFrame = bind(this._nextFrame, this);
    ref = this._reader, this.width = ref.width, this.height = ref.height;
    this._frames = decodeFrames(this._reader);
    this._loopCount = this._reader.loopCount();
    this._loops = 0;
    this._frameIndex = 0;
    this._running = false;
  }

  Animator.prototype.start = function() {
    this._lastTime = new Date().valueOf();
    this._delayCompensation = 0;
    this._running = true;
    setTimeout(this._nextFrame, 0);
    return this;
  };

  Animator.prototype.stop = function() {
    this._running = false;
    return this;
  };

  Animator.prototype.reset = function() {
    this._frameIndex = 0;
    this._loops = 0;
    return this;
  };

  Animator.prototype._nextFrame = function() {
    requestAnimationFrame(this._nextFrameRender);
  };

  Animator.prototype._nextFrameRender = function() {
    var frame, ref;
    if (!this._running) {
      return;
    }
    frame = this._frames[this._frameIndex];
    if ((ref = this.onFrame) != null) {
      ref.apply(this, [frame, this._frameIndex]);
    }
    return this._enqueueNextFrame();
  };

  Animator.prototype._advanceFrame = function() {
    this._frameIndex += 1;
    if (this._frameIndex >= this._frames.length) {
      if (this._loopCount !== 0 && this._loopCount === this._loops) {
        this.stop();
      } else {
        this._frameIndex = 0;
        this._loops += 1;
      }
    }
  };

  Animator.prototype._enqueueNextFrame = function() {
    var actualDelay, delta, frame, frameDelay;
    this._advanceFrame();
    while (this._running) {
      frame = this._frames[this._frameIndex];
      delta = new Date().valueOf() - this._lastTime;
      this._lastTime += delta;
      this._delayCompensation += delta;
      frameDelay = frame.delay * 10;
      actualDelay = frameDelay - this._delayCompensation;
      this._delayCompensation -= frameDelay;
      if (actualDelay < 0) {
        this._advanceFrame();
        continue;
      } else {
        setTimeout(this._nextFrame, actualDelay);
        break;
      }
    }
  };

  Animator.prototype.animateInCanvas = function(canvas, setDimension) {
    var ctx;
    if (setDimension == null) {
      setDimension = true;
    }
    if (setDimension) {
      canvas.width = this.width;
      canvas.height = this.height;
    }
    ctx = canvas.getContext('2d');
    if (this.onDrawFrame == null) {
      this.onDrawFrame = function(ctx, frame, i) {
        return ctx.drawImage(frame.buffer, frame.x, frame.y);
      };
    }
    if (this.onFrame == null) {
      this.onFrame = (function(_this) {
        return function(frame, i) {
          var ref, saved;
          if (frame.buffer == null) {
            frame.buffer = createBufferCanvas(frame, _this.width, _this.height);
          }
          if (typeof _this.disposeFrame === "function") {
            _this.disposeFrame();
          }
          switch (frame.disposal) {
            case 2:
              _this.disposeFrame = function() {
                return ctx.clearRect(0, 0, canvas.width, canvas.height);
              };
              break;
            case 3:
              saved = ctx.getImageData(0, 0, canvas.width, canvas.height);
              _this.disposeFrame = function() {
                return ctx.putImageData(saved, 0, 0);
              };
              break;
            default:
              _this.disposeFrame = null;
          }
          return (ref = _this.onDrawFrame) != null ? ref.apply(_this, [ctx, frame, i]) : void 0;
        };
      })(this);
    }
    this.start();
    return this;
  };

  return Animator;

})();

gifler.Animator = Animator;

gifler.decodeFrames = decodeFrames;

gifler.createBufferCanvas = createBufferCanvas;

if (typeof window !== "undefined" && window !== null) {
  window.gifler = gifler;
}

if (typeof module !== "undefined" && module !== null) {
  module.exports = gifler;
}
